"use strict";Object.defineProperty(exports, "__esModule", {value: true});// src/core/index.ts










var _common = require('@vue-macros/common');




var _api = require('@vue-macros/api');
var PROPS_VARIABLE_NAME = `${_common.HELPER_PREFIX}props`;
async function transformDefineProp(code, id, edition = "kevinEdition", isProduction = false) {
  if (!code.includes(_common.DEFINE_PROP))
    return;
  const { scriptSetup, getSetupAst } = _common.parseSFC.call(void 0, code, id);
  if (!scriptSetup)
    return;
  const setupAst = getSetupAst();
  const offset = scriptSetup.loc.start.offset;
  const s = new (0, _common.MagicString)(code);
  const { walkCall, genRuntimeProps } = (edition === "kevinEdition" ? kevinEdition : johnsonEdition)({ s, offset, resolveTSType });
  let hasDefineProps = false;
  let hasDefineProp = false;
  _common.walkAST.call(void 0, setupAst, {
    enter(node, parent) {
      if (_common.isCallOf.call(void 0, node, _common.DEFINE_PROP)) {
        hasDefineProp = true;
        const propName = walkCall(node, parent);
        s.overwriteNode(
          node,
          `${_common.importHelperFn.call(void 0, 
            s,
            offset,
            "toRef"
          )}(${PROPS_VARIABLE_NAME}, ${JSON.stringify(propName)})`,
          { offset }
        );
      } else if (_common.isCallOf.call(void 0, node, _common.DEFINE_PROPS)) {
        hasDefineProps = true;
      }
    }
  });
  if (hasDefineProps && hasDefineProp)
    throw new Error(
      `${_common.DEFINE_PROP} can not be used in the same file as ${_common.DEFINE_PROPS}.`
    );
  const runtimeProps = await genRuntimeProps();
  if (runtimeProps)
    s.prependLeft(
      offset,
      `
const ${PROPS_VARIABLE_NAME} = defineProps(${runtimeProps});
`
    );
  return _common.getTransformResult.call(void 0, s, id);
  async function resolveTSType(type) {
    const resolved = await _api.resolveTSReferencedType.call(void 0, {
      scope: {
        filePath: id,
        content: scriptSetup.content,
        ast: setupAst.body
      },
      type
    });
    return resolved && _api.toRuntimeTypeString.call(void 0, await _api.inferRuntimeType.call(void 0, resolved), isProduction);
  }
}
var kevinEdition = ({ s, offset, resolveTSType }) => {
  const props = [];
  return {
    walkCall(node, parent) {
      var _a;
      const [name, definition] = node.arguments;
      let propName;
      if (!name) {
        if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier")
          throw new Error(
            `A variable must be used to receive the return value of ${_common.DEFINE_PROP} when the first argument is not passed. (kevinEdition)`
          );
        propName = parent.id.name;
      } else if (name.type !== "StringLiteral") {
        throw new Error(
          `The first argument of ${_common.DEFINE_PROP} must be a literal string. (kevinEdition)`
        );
      } else {
        propName = name.value;
      }
      props.push({
        name: propName,
        definition: definition ? s.sliceNode(definition, { offset }) : void 0,
        typeParameter: (_a = node.typeParameters) == null ? void 0 : _a.params[0]
      });
      return propName;
    },
    async genRuntimeProps() {
      if (props.length === 0)
        return;
      const isAllWithoutOptions = props.every(
        ({ definition, typeParameter }) => !definition && !typeParameter
      );
      if (isAllWithoutOptions) {
        return stringifyArray(props.map(({ name }) => name));
      }
      let propsString = "{\n";
      for (const { name, definition, typeParameter } of props) {
        let def;
        const type = typeParameter && await resolveTSType(typeParameter);
        if (definition && !type) {
          def = definition;
        } else {
          const pairs = [];
          if (type)
            pairs.push(`type: ${type}`);
          if (definition)
            pairs.push(`...${definition}`);
          def = `{ ${pairs.join(", ")} }`;
        }
        propsString += `  ${JSON.stringify(name)}: ${def},
`;
      }
      propsString += "}";
      return propsString;
    }
  };
};
var johnsonEdition = ({ s, offset, resolveTSType }) => {
  const props = [];
  return {
    walkCall(node, parent) {
      var _a;
      const [value, required, rest] = node.arguments;
      if (parent.type !== "VariableDeclarator" || parent.id.type !== "Identifier")
        throw new Error(
          `A variable must be used to receive the return value of ${_common.DEFINE_PROP} (johnsonEdition)`
        );
      const propName = parent.id.name;
      props.push({
        name: propName,
        value: value ? s.sliceNode(value, { offset }) : void 0,
        required: required ? s.sliceNode(required, { offset }) : void 0,
        rest: rest ? s.sliceNode(rest, { offset }) : void 0,
        typeParameter: (_a = node.typeParameters) == null ? void 0 : _a.params[0]
      });
      return propName;
    },
    async genRuntimeProps() {
      if (props.length === 0)
        return;
      const isAllWithoutOptions = props.every(
        ({ typeParameter, value, required, rest }) => !typeParameter && !value && !required && !rest
      );
      if (isAllWithoutOptions) {
        return stringifyArray(props.map(({ name }) => name));
      }
      let propsString = "{\n";
      for (const { name, value, required, rest, typeParameter } of props) {
        let def;
        const type = typeParameter && await resolveTSType(typeParameter);
        if (rest && !value && !required && !type) {
          def = rest;
        } else {
          const pairs = [];
          if (type)
            pairs.push(`type: ${type}`);
          if (value)
            pairs.push(`default: ${value}`);
          if (required)
            pairs.push(`required: ${required}`);
          if (rest)
            pairs.push(`...${rest}`);
          def = `{ ${pairs.join(", ")} }`;
        }
        propsString += `  ${JSON.stringify(name)}: ${def},
`;
      }
      propsString += "}";
      return propsString;
    }
  };
};
function stringifyArray(strs) {
  return `[${strs.map((s) => JSON.stringify(s)).join(", ")}]`;
}







exports.PROPS_VARIABLE_NAME = PROPS_VARIABLE_NAME; exports.transformDefineProp = transformDefineProp; exports.kevinEdition = kevinEdition; exports.johnsonEdition = johnsonEdition; exports.stringifyArray = stringifyArray;
